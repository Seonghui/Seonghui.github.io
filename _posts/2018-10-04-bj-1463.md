---
layout: post
title: "[백준/1463] 1로 만들기"
tags: [boj, java, dp]
---
> Baekjoon Online Judge - [1463](https://www.acmicpc.net/problem/1463)

## Review
* 풀이를 보고도 무슨 소리인지 몰라 이해하는데 한참을 쏟았던 문제.
* 결국 for문에 값을 하나하나 대입하고 나서야 깨달음을 얻을 수 있었다.
* 일단 점화식으로 나타내면 이렇다. 
* -1을 했을 때: `A[n] = A[n - 1] + 1`
* n % 2 == 0일 때: `A[n] = A[n / 2 == 0] + 1`
* n % 3 == 0일 때: `A[n] = A[n / 3 == 0] + 1`
* 횟수를 계산해야 하기 때문에 1을 더한다.
* -1을 했을 때의 값과 2나 3으로 나누어 떨어졌을 때의 값을 계산해 최솟값을 배열의 값에 넣어주면 되는 문제이다.
* 처음부터 2와 3으로 나누어 떨어지지 않는 경우 -1했을 때의 값이 최솟값이 된다.
* 이해하는데 오래 걸리고 구글링으로 겨우 풀어서 부끄럽지만, DP를 이해하는 과정을 남기기 위해서 포스팅을 한다.

## Code (JAVA) - Bottom-up
```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int[] arr = new int[n + 1];
    arr[0] = arr[1] = 0;
    
    for(int i = 2; i <= n; i++) {
      arr[i] = arr[i - 1] + 1;
      
      if(i % 2 == 0 && arr[i] > arr[i / 2] + 1) {
        arr[i] = arr[i / 2] + 1;
      }
      
      if(i % 3 == 0 && arr[i] > arr[i / 3] + 1) {
        arr[i] = arr[i / 3] + 1;
      }
      
    }
    System.out.println(arr[n]);
    sc.close();
  }
}
```

## Code (JAVA) - Top-down
```java
import java.io.*;

public class Main {
  
  static int[] dp;
  
  public static int dp(int n) {
    if(n <= 1) {
      return 0;
    } else if(dp[n] != 0) {
      return dp[n];
    } else {
      dp[n] = dp(n - 1) + 1;
      if(n % 3 == 0 && dp[n] > dp(n / 3) + 1) {
        dp[n] = dp(n / 3) + 1;
      }
      if(n % 2 == 0 && dp[n] > dp(n / 2) + 1) {
        dp[n] = dp(n / 2) + 1;
      }
      
    }
    return dp[n];
  }
  
  public static void main(String args[]) throws IOException{
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int N = Integer.parseInt(br.readLine());
    dp = new int[N + 1];
    System.out.println(dp(N));
    
  }
  
}
```